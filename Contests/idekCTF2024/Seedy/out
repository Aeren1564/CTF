class Twister:
	N = 624
	M = 397
	A = 0x9908b0df

	def __init__(self, init_index = N):
		self.state = [ [ (1 << (32 * i + (31 - j))) for j in range(32) ] for i in range(624)]
		self.index = init_index

	@staticmethod
	def _xor(a, b):
		return [x ^ y for x, y in zip(a, b)]

	@staticmethod
	def _and(a, x):
		return [ v if (x >> (31 - i)) & 1 else 0 for i, v in enumerate(a) ]

	@staticmethod
	def _shiftr(a, x):
		return [0] * x + a[:-x]

	@staticmethod
	def _shiftl(a, x):
		return a[x:] + [0] * x

	def get32bits(self):
		if self.index >= self.N:
			for kk in range(self.N):
				y = self.state[kk][:1] + self.state[(kk + 1) % self.N][1:]
				z = [ y[-1] if (self.A >> (31 - i)) & 1 else 0 for i in range(32) ]
				self.state[kk] = self._xor(self.state[(kk + self.M) % self.N], self._shiftr(y, 1))
				self.state[kk] = self._xor(self.state[kk], z)
			self.index = 0

		y = self.state[self.index]
		y = self._xor(y, self._shiftr(y, 11))
		y = self._xor(y, self._and(self._shiftl(y, 7), 0x9d2c5680))
		y = self._xor(y, self._and(self._shiftl(y, 15), 0xefc60000))
		y = self._xor(y, self._shiftr(y, 18))
		self.index += 1

		return y

	def getrandbits(self, bit):
		return self.get32bits()[:bit]

class Solver:
	def __init__(self):
		self.equations = []
		self.outputs = []

	def insert(self, equation, output):
		for eq, o in zip(self.equations, self.outputs):
			lsb = eq & -eq
			if equation & lsb:
				equation ^= eq
				output ^= o

		if equation == 0:
			if output != 0:
				print("Infeasible set of equations")
				assert False
			return

		lsb = equation & -equation
		for i in range(len(self.equations)):
			if self.equations[i] & lsb:
				self.equations[i] ^= equation
				self.outputs[i] ^= output

		self.equations.append(equation)
		self.outputs.append(output)

	def solve(self):
		num = 0
		for i, eq in enumerate(self.equations):
			if self.outputs[i]:
				# Assume every free variable is 0
				num |= eq & -eq

		state = [ (num >> (32 * i)) & 0xFFFFFFFF for i in range(624) ]
		return state

import random

with open("output.txt", 'r') as f:
	out	=	f.read().strip()

num = len(out)
twister = Twister()

outputs = [int(out[i]) for i in range(num)]
equations = [ twister.getrandbits(1) for _ in range(num) ]

solver = Solver()

for i in range(0, 32):
	solver.insert(1 << i, int(i == 31))
for i in range(num):
	solver.insert(equations[i][0], outputs[i] & 1)

state = solver.solve()
recovered_state = (3, tuple(state + [624]), None)

print(f'{recovered_state = }')

random.setstate(recovered_state)

assert recovered_state[1][0] == 2147483648

for i in range(len(out)):
	if int(out[i]) != random.getrandbits(1):
		print("Incorrect value at", i)
		assert False
