

# This file was *autogenerated* from the file server.sage
from sage.all_cmdline import *   # import sage library

_sage_const_263 = Integer(263); _sage_const_128 = Integer(128); _sage_const_512 = Integer(512); _sage_const_768 = Integer(768); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_61 = Integer(61); _sage_const_60 = Integer(60); _sage_const_3 = Integer(3); _sage_const_20 = Integer(20); _sage_const_4 = Integer(4); _sage_const_18 = Integer(18); _sage_const_16 = Integer(16); _sage_const_24 = Integer(24)
from Crypto.Util.number import bytes_to_long as b2l
from Crypto.Util.number import long_to_bytes as l2b
from Crypto.Util.number import getPrime
import random
import os

n, q = _sage_const_263 , _sage_const_128 
Zx = ZZ['x']; (x,) = Zx._first_ngens(1)

_p, _q = getPrime(_sage_const_512 ), getPrime(_sage_const_512 )
N = _p * _q
e = getPrime(_sage_const_768 )
d = int(inverse_mod(e, (_p**_sage_const_2  - _sage_const_1 ) * (_p**_sage_const_2  - _p) * (_q**_sage_const_2  - _sage_const_1 ) * (_q**_sage_const_2  - _q)))
Q = QuaternionAlgebra(Zmod(N), -_sage_const_1 , -_sage_const_1 )
i, j, k = Q.gens()

def conv(f, g):
	
	return (f * g) % (x**n - _sage_const_1 )

def bal_mod(f, q):

	coef = list(
		( (f[idx] + q // _sage_const_2 ) % q ) - q // _sage_const_2  for idx in range(n)
	)
	return Zx(coef)  % (x**n - _sage_const_1 )

def rand_poly(d1, d2):

	coef = d1 * [_sage_const_1 ] + d2 * [-_sage_const_1 ] + (n - d1 - d2) * [_sage_const_0 ]
	random.shuffle(coef)
	return Zx(coef)

def inv_mod_p(f, p):

	T = Zx.change_ring(Zmod(p)).quotient(x**n - _sage_const_1 )
	return Zx(lift(_sage_const_1  / T(f)))

def inv_mod_2k(f, q):

	assert q.is_power_of(_sage_const_2 )
	g = inv_mod_p(f, _sage_const_2 )

	while True:
		r = bal_mod(conv(g, f), q)
		if r == _sage_const_1 : return g
		g = bal_mod(conv(g, _sage_const_2  - r), q)

def key_gen():

	while True:
		try:
			f = rand_poly(_sage_const_61 , _sage_const_60 )
			f3 = bal_mod(inv_mod_p(f, _sage_const_3 ), _sage_const_3 )
			fq = inv_mod_2k(f, q)
			break
		except:
			pass
	g = rand_poly(_sage_const_20 , _sage_const_20 )
	
	pub_key = bal_mod(_sage_const_3  * conv(fq, g), q)
	priv_key = (f, f3)

	return pub_key, priv_key

def encode(val):

	poly = _sage_const_0 
	for idx in range(n):
		poly += ( (val % _sage_const_3 ) - _sage_const_1  ) * x**idx
		val //= _sage_const_3 
	return poly

def decode(poly):

	val = _sage_const_0 
	for idx in range(n):
		val += (poly[idx] + _sage_const_1 ) * _sage_const_3 **idx
	return val

def poly_to_Q(poly):

	nn = n // _sage_const_4 
	start = [idx * nn for idx in range(_sage_const_4 )] + [n]
	coef = []

	for idx in range(_sage_const_4 ):
		val = _sage_const_0 
		for jdx in range(start[idx], start[idx + _sage_const_1 ]):
			val += (poly[jdx] + _sage_const_1 ) * _sage_const_3 **(jdx - start[idx])
		coef += [val]

	return (coef[_sage_const_0 ] + coef[_sage_const_1 ] * i + coef[_sage_const_2 ] * j + coef[_sage_const_3 ] * k)

def qow(q, x):

	return q ** int(sum(x.coefficient_tuple()))

def encrypt(m, pub_key):

	r = rand_poly(_sage_const_18 , _sage_const_18 )

	return bal_mod(conv(pub_key, r) + encode(m), q)

if __name__ == '__main__':

	pub_key1, priv_key1 = key_gen()
	pub_key2, priv_key2 = key_gen()

	nonce1 = os.urandom(_sage_const_16 )
	nonce2 = os.urandom(_sage_const_16 )

	print(f"enc1 = {encrypt(b2l(nonce1), pub_key1)}")
	print(f"enc2 = {encrypt(b2l(nonce2), pub_key2)}")

	print("A free gift for you, I'm so kind!")
	print(f"N = {N}")

	x1, x2 = poly_to_Q(rand_poly(_sage_const_20 , _sage_const_24 )), poly_to_Q(rand_poly(_sage_const_20 , _sage_const_24 ))
	
	"""
		Pick a random r and compute v = r**e + x1/x2
		Then k1 or k2 = r and you should be able to retrieve the corresponding key
	"""

	coef = input("Give me your choice: ").split(", ")
	v = int(coef[_sage_const_0 ]) + int(coef[_sage_const_1 ]) * i + int(coef[_sage_const_2 ]) * j + int(coef[_sage_const_3 ]) * k

	k1 = (v - x1) ** d
	k2 = (v - x2) ** d

	c1 = (qow(poly_to_Q(priv_key1[_sage_const_0 ]), k1), qow(poly_to_Q(priv_key1[_sage_const_1 ]), k1))
	c2 = (qow(poly_to_Q(priv_key2[_sage_const_0 ]), k2), qow(poly_to_Q(priv_key2[_sage_const_1 ]), k2))

	print(f"c1 = {c1}")
	print(f"c2 = {c2}")

	guess = bytes.fromhex(input("Make a guess: "))

	if guess == nonce1 + nonce2:
		print(":>")
		flag = os.getenv("flag", "idek{fake_flag}").encode()
		print(flag)
	else:
		print(":<")

