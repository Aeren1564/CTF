# Stream Ciphers: ChaCha20
# Block Ciphers: AES
from Crypto.Cipher import AES, ChaCha20
# sha256
from hashlib import *
# pad
from Crypto.Util.Padding import *
from Crypto.Util.number import *
import math
import os
import zlib
import string
import queue
import faulthandler
faulthandler.enable()

# in ascii order
flag_char_pool = string.digits + string.ascii_uppercase + '_' + string.ascii_lowercase

# Source: https://github.com/rkm0959/Inequality_Solving_with_CVP/blob/main/solver.sage
def solve_inequality_with_CVP(M, lbounds, ubounds, weight = None):
	from sage.modules.free_module_integer import IntegerLattice

	# Directly taken from rbtree's LLL repository
	# From https://oddcoder.com/LOL-34c3/, https://hackmd.io/@hakatashi/B1OM7HFVI
	def Babai_CVP(mat, target):
		M = IntegerLattice(mat, lll_reduce=True).reduced_basis
		G = M.gram_schmidt()[0]
		diff = target
		for i in reversed(range(G.nrows())):
			diff -=  M[i] * ((diff * G[i]) / (G[i] * G[i])).round()
		return target - diff

	mat, lb, ub = copy(M), copy(lbounds), copy(ubounds)
	num_var  = mat.nrows()
	num_ineq = mat.ncols()

	max_element = 0 
	for i in range(num_var):
		for j in range(num_ineq):
			max_element = max(max_element, abs(mat[i, j]))

	if weight == None:
		weight = num_ineq * max_element

    # sanity checker
	if len(lb) != num_ineq:
		#print("Fail: len(lb) != num_ineq")
		return

	if len(ub) != num_ineq:
		#print("Fail: len(ub) != num_ineq")
		return

	for i in range(num_ineq):
		if lb[i] > ub[i]:
			#print("Fail: lb[i] > ub[i] at index", i)
			return

    	# heuristic for number of solutions
	DET = 0

	if num_var == num_ineq:
		DET = abs(mat.det())
		num_sol = 1
		for i in range(num_ineq):
			num_sol *= (ub[i] - lb[i])
		if DET == 0:
			pass
			#print("Zero Determinant")
		else:
			num_sol //= DET
			# + 1 added in for the sake of not making it zero...
			#print("Expected Number of Solutions : ", num_sol + 1)

	# scaling process begins
	max_diff = max([ub[i] - lb[i] for i in range(num_ineq)])
	applied_weights = []

	print(f"{max_diff = }")

	for i in range(num_ineq):
		ineq_weight = weight if lb[i] == ub[i] else max_diff // (ub[i] - lb[i])
		applied_weights.append(ineq_weight)
		for j in range(num_var):
			mat[j, i] *= ineq_weight
		lb[i] *= ineq_weight
		ub[i] *= ineq_weight

	# Solve CVP
	target = vector([(lb[i] + ub[i]) // 2 for i in range(num_ineq)])
	result = Babai_CVP(mat, target)

	for i in range(num_ineq):
		if (lb[i] <= result[i] <= ub[i]) == False:
			#print("Fail : inequality does not hold after solving")
			break
    
    	# recover x
	fin = None

	if DET != 0:
		mat = mat.transpose()
		fin = mat.solve_right(result)
	
	## recover your result
	return result, applied_weights, fin

msgs = [
	b"https://www.youtube.com/watch?v=kv4UD4ICd_0",
	b"https://www.youtube.com/watch?v=IijOKxLclxE",
	b"https://www.youtube.com/watch?v=GH6akWYAtGc",
	b"https://www.youtube.com/watch?v=Y3JhUFAa9bk",
	b"https://www.youtube.com/watch?v=FGID8CJ1fUY",
	b"https://www.youtube.com/watch?v=_BfmEjHVYwM",
	b"https://www.youtube.com/watch?v=zH7wBliAhT0",
	b"https://www.youtube.com/watch?v=NROQyBPX9Uo",
	b"https://www.youtube.com/watch?v=ylH6VpJAoME",
	b"https://www.youtube.com/watch?v=hI34Bhf5SaY",
	b"https://www.youtube.com/watch?v=bef23j792eE",
	b"https://www.youtube.com/watch?v=ybvXNOWX-dI",
	b"https://www.youtube.com/watch?v=dt3p2HtLzDA",
	b"https://www.youtube.com/watch?v=1Z4O8bKoLlU",
	b"https://www.youtube.com/watch?v=S53XDR4eGy4",
	b"https://www.youtube.com/watch?v=ZK64DWBQNXw",
	b"https://www.youtube.com/watch?v=tLL8cqRmaNE",
]

sigs = [(110691008688663177877467360421094798858868018563106291538659845545571587849568, 2392737915578605127615203258554279480687953095818323604306611775366481353759), (92056402747248457538327599722056893632136822047889182157044122167999739160206, 33276601899815240976378293346628285607051097963090921502583262358982280915378), (71461874354139956128069650870418871454892183695852948196214575700470984939671, 366525796663247544968163577160634681148539834465012178942056324547677746410), (47250935088194996781553777427550602903670475390384774443038688249617506691911, 92721279553984222932694086616290088070041996911998044806560947224715804686082), (11096954736868474910895639188471385434724683040732088019208126386732245637988, 39004880498159094965822440440907850316858200979766596881155564676786497695835), (23572293505827172028063316997270115699765155275545328411889760508775352691595, 63525853115459346357961650395338169221762429729349086483512270058456492557208), (111291119628420293376334119508212325574658395485387277271430178002414939148503, 279066689888436554831424032975598204885764956638303912729368918823710200628), (50142138397534141562594062542443917106409688041992216538154797971049108302203, 22162108521873595580922032574324460455503409429131875337905358885027039254642), (2663991996815497452788391984456432487752678860055034701963749836583187364565, 86636712091706174319191627420766950278366588330295305794958262787339413540438), (106990344273733040335907519930502945116954921998325879678096372179223259876809, 104089804677625608008986032697745737598358602580293284104559101743937775854875), (84559677502612055904691192237267417120544105992086625040389777880889473041225, 39672875443418919935143394416899268040573381751126457425603260195569702047561), (66493914018386239834437005719919906973428926923603405479919696167059860240241, 87771809989337500188583008961667732481008054495415459510964841702951487581569), (20296352065286208638213886637409863817881850694479247754842204663980940644145, 43946573897990609451435823887700378678109705573344071890720149037793188444733), (101783265361831587788954466513208483758050851021105815045891381787319374669323, 31930127081282371700656111486638437983706806092245006060098000814372474795867), (45975802065553989023445899753570444770082783407560242199470822501881817893694, 86960822556480021011059448414076609378388593194609589714682591536986575030274), (78074548671103010115177064112973923512640628504791312061984966025724165910888, 89200311041993596512788691139955842129535445566173901734952736180876719823733), (18120323925655407086033613402537197975691397345829424313712416316513324207908, 19050772992573685853818383040505931334895229883003814146615553553781969033285)]
ct = b'\xc6*\x17\xcce\xc1y\xb8\xb4\x8d\x87L\xf8\x81QK\xf4\x02\xf2\xf7\x8d\xe0\xe8\x92\xc7\xe7\x8fg\xb1M\xb4.\x89\x18\xf5\x7f\xed\xc3I\x92\x82\xfd\xfe9\x95\xc9(\x90\xce\x93\xb9+\xce\x958\xf3\x05PH'
nonce = b'6\xe7m\xcc\x8e\x0eG '

def find_d(REM, msgs, sigs, ct, nonce, target_mask):
	from fastecdsa.curve import secp256k1
	from hashlib import sha256

	G = secp256k1.G
	q = secp256k1.q

	print(f"{q = }")

	assert len(sigs) == len(msgs)

	def verify(d):
		for (r, s), m in zip(sigs, msgs):
			z = int.from_bytes(sha256(m).digest(), "big") % q
			k = ((z + r * d) * pow(s, -1, q)) % q
			if (int(k) * G).x != r:
				return False
		return True

	n = len(sigs)

	def _solve_for_mask(mask):
		# print(f"{mask = }")
		M = Matrix(ZZ, n + 1, n + 1)
		lbounds = [0] * (n + 1)
		ubounds = [0] * (n + 1)
		for i, ((r, s), m) in enumerate(zip(sigs, msgs)):
			z = int.from_bytes(sha256(m).digest(), "big") % q
			M[i, i] = q
			M[n, i] = r
			if (mask >> i & 1) == 1:
				lbounds[i] = 1
				ubounds[i] = q - z - 1
			else:
				lbounds[i] = q - z + 1
				ubounds[i] = q - 1
		M[n, n] = 1
		# lbounds[n] = 0
		# ubounds[n] = q - 1
		lbounds[n] = q * 1341 // 10000
		ubounds[n] = q * 1342 // 10000 - 1
		print(f"{lbounds[n] = }")
		print(f"{ubounds[n] = }")

		ret = solve_inequality_with_CVP(M, lbounds, ubounds)
		if ret == None:
			return

		result, applied_weights, fin = ret

		print(f"{result = }, {applied_weights = }, {fin = }")

		d = int(fin[n])

		print(f"candidate {d = }")

		# sanity check
		for i, ((r, s), m) in enumerate(zip(sigs, msgs)):
			z = int.from_bytes(sha256(m).digest(), "big") % q
			if (mask >> i & 1) == 1:
				assert z + r * d % q < q
			else:
				assert z + r * d % q >= q
		if verify(d):
			return d

	def find_flag(d):
		key = sha256(str(d).encode()).digest()
		cipher = AES.new(key, AES.MODE_CTR, nonce = nonce)
		flag = cipher.decrypt(ct)
		return flag

	if target_mask == None:
		for mask in range(1 << n - 3):
			d = _solve_for_mask(mask << 3 | REM)
			if d != None:
				flag = find_flag(d)
				if flag[0 : 6] == "hitcon":
					return flag
	else:
		mask = target_mask
		d = _solve_for_mask(mask)
		print(f"trying {d = }")
		if d != None:
			flag = find_flag(d)
			if flag[0 : 6] == b"hitcon":
				return flag

test_sigs = [(72516089384589129761969500229884860332587768926986776549893332089685364815748, 101134445710618284251496733523321431442056960134494057326321728133545490490955), (22417156320412470217144734918968740014790095556761512308077789568907096525925, 96827362854713323710695348341318642319749934458385762003753527846247134880746), (15992087925511567324903057865293128892182447881078196212447485207593017011494, 71862835548645775012295590075247911219986704156851997931706238045004028907728), (65228646770683863662770539037978187559616838441477438156549158915465742885611, 82269303466545568525770414686549566328792728707936363566400033279295431346566), (8301758826524342055789753147704266150862751177215030029592174124302444772533, 20617448594331029408936715470480320563079858884727500862309288320427734641761), (86546361371755485850849287932076884627141833902662161562454420139336793613913, 29686073934603089288697155334817852324006804207651039418041704898917202136258), (55957601061367572388455538791857562810093594437260205188074453517593314240284, 59062427680911029787255008998010616993379505948007947250771262606623035052529), (9828463015385064155273273495825263379239538962090058191204102231562502323867, 75945946168507832517242022363030305489698410771870946259944004928048346861793), (22325958296650408099825187990486080791664041743311263776363097353932851771081, 61067508553273593401643954825578512076650679416599427709698527339986314320915), (101013786138979657209920715380130941952896881079827433349061143672008793540812, 21469882622449754197529113616530600909433279757814382134170667756900890025621), (33313684897767499999222436959275976180575558224261531158034693861998987185080, 97099330366904799986252755873372852846076364722935252360018767375767495935935), (56796636087468841512014421388859968929553462161287426012681570037795851614339, 75732291804698643970973408221841406156447628927917661358189866330894915465422), (114303659960751774723586366588957095491428606456828748584494656991128084889982, 105409879910131323520528266052595915199354253154674380037933985679537619149004), (92135462792321607569957774867375092447022647028099226487541883987648371927266, 22960298364764831927435459859668802242303006247381809837951999391167917469694), (3594534820158946403152565365620446187049493242797137587282130693961342985098, 88180604209471612316711539213446649477518614582602070526162967400591295940913), (18503991000027300666803771822029893320323528216380202666703489116186303462915, 1339270955102143782791350435365594993534301512726444407971848992372683380578), (115391150306845949486947455678999736282495060939595867480426384501547682597463, 47946480073573734473779917375198264522249750423289633070381960079951635801)]
test_ct = b'\xa0e\x7f~\xa7\x07\xe4\xc2\x12G^\xd5i\x1c\xf1\xd4o'
test_nonce = b'\x01AN\xa6\xd0\xe0\xebI'

#flag = find_d(0, msgs, sigs, ct, nonce, None)
flag = find_d(0, msgs, test_sigs, test_ct, test_nonce, 66153)
print(flag)

# actual = 15536867330988408474992152340377233221418858456921712303879310164997996596744
# mine   = 46318858139707990691309940864227677181762215801450323832782789770314679291308