from CTF_Library import *

E1 = 17599828213549223253832044274649684283770977196846184512551517947600728059 
E2 = 13524024408490227176018717697716068955892095093578246398907145843636542721
E3 = lcm(E1, E2)
N = 39857078746406469131129281921490520306196739933449401384580614683236877901453146754149222509812535866333862501431453065249306959004319408436548574942416212329735258587670686655658056553446879680643872518009328886406310298097685861873954727153720761248262606469217940464611561028443119183464419610396387619860313813067179519809796028310723320608528262638653826016645983671026819244220510314301178181698134390850683834304169240632402535087021483298892547974104858755498823118164815682452718215716370727477136888839954993949013970026988378086175471190518276414200966496353144747778470590767485019943178534397845127421058830430797806265311195099187747227867325234593386438995618936934586514932401108874934000734850169069717060963988677462779177959990601405850727404268354600078746523164279

R = Zmod(N)
remP = CRT([1, N], [E1, E2])
remQs = [CRT([int(r), 1], [E1, E2]) for r in Zmod(E1)(N).nth_root(2, all = True)]
print(f"{N.bit_length() = }")
print(f"{(E1 * E2).bit_length() = }")
for nbit in range(800, 1000):
	print(f"{nbit = }")
	for remQ in remQs:
		for _, Q in coppersmith_univariate(N, [remQ * remQ, 2 * remQ * E3, E3 * E3], 2**nbit):
			print(f"r3ctf{hashlib.sha256(str(Q).encode()).hexidigest()}")
			exit()
